from enum import Enum, auto


class BookingState(Enum):
    IDLE = auto()
    ROOM_SELECTED = auto()
    BOOKING_CONFIRMED = auto()
    PAID = auto()
    BOOKING_CANCELLED = auto()


class BookingStateMachine:
    def __init__(self):
        self.state = BookingState.IDLE
        self.selected_room = None
        print(f"Начальное состояние: {self.state.name}")

    # --- Действия пользователя ---
    def select_room(self, room_number):
        if self.state == BookingState.IDLE:
            self.state = BookingState.ROOM_SELECTED
            self.selected_room = room_number
            print(f"Комната {room_number} выбрана → Состояние: ROOM_SELECTED")
        else:
            print("Невозможно выбрать номер на данном этапе.")

    def change_room(self, room_number):
        if self.state == BookingState.ROOM_SELECTED:
            self.selected_room = room_number
            print(f"Изменён номер на {room_number}")
        else:
            print("Нельзя изменить номер после подтверждения бронирования.")

    def confirm_booking(self):
        if self.state == BookingState.ROOM_SELECTED:
            self.state = BookingState.BOOKING_CONFIRMED
            print("Бронирование подтверждено → Состояние: BOOKING_CONFIRMED")
        else:
            print("Нельзя подтвердить бронирование сейчас.")

    def pay(self, amount):
        if self.state == BookingState.BOOKING_CONFIRMED:
            self.state = BookingState.PAID
            print(f"Оплата {amount} успешно получена → Состояние: PAID")
        else:
            print("Оплата невозможна. Бронирование не подтверждено.")

    def cancel(self):
        if self.state in [
            BookingState.ROOM_SELECTED,
            BookingState.BOOKING_CONFIRMED
        ]:
            self.state = BookingState.BOOKING_CANCELLED
            print("Бронирование отменено → Состояние: BOOKING_CANCELLED")
        elif self.state == BookingState.PAID:
            print("Нельзя отменить — бронирование уже оплачено.")
        else:
            print("Нет активного бронирования для отмены.")

    # Дополнительная функция: расчет скидки
    def calculate_discount(self, total_amount, discount_percent):
        discount = total_amount * (discount_percent / 100)
        new_total = total_amount - discount
        print(f"Скидка {discount_percent}% → новая сумма: {new_total}")
        return new_total

    # История бронирования
    def save_history(self):
        print(f"Сохранение истории: номер={self.selected_room}, состояние={self.state.name}")


# ----------------------------
# Пример работы state machine
# ----------------------------

if __name__ == "__main__":
    booking = BookingStateMachine()

    booking.select_room(305)
    booking.change_room(312)
    booking.confirm_booking()

    price = 20000
    price = booking.calculate_discount(price, 10)

    booking.pay(price)

    booking.save_history()


 2 задание

from abc import ABC, abstractmethod


# ---------- STATE INTERFACE ----------
class State(ABC):
    @abstractmethod
    def next_state(self, request):
        pass

    @abstractmethod
    def cancel(self, request):
        pass


# ---------- STATES ----------
class Created(State):
    def next_state(self, request):
        print("Заявка отправлена клиенту. Статус: Ожидает оплаты")
        request.state = PendingPayment()

    def cancel(self, request):
        print("Заявка отменена.")
        request.state = Cancelled()


class PendingPayment(State):
    def next_state(self, request):
        print("Клиент оплатил заявку. Статус: Оплачена")
        request.state = Paid()

    def cancel(self, request):
        print("Клиент не успел оплатить. Заявка отменена.")
        request.state = Cancelled()


class Paid(State):
    def next_state(self, request):
        print("Оплата подтверждена системой. Статус: Подтверждена")
        request.state = Confirmed()

    def cancel(self, request):
        print("Нельзя отменить — оплата уже произведена!")
        # остаёмся в Paid


class Confirmed(State):
    def next_state(self, request):
        print("Бронирование уже подтверждено.")

    def cancel(self, request):
        print("Нельзя отменить — бронирование уже подтверждено.")


class Cancelled(State):
    def next_state(self, request):
        print("Заявка отменена. Дальнейшие действия невозможны.")

    def cancel(self, request):
        print("Заявка уже отменена.")


# ---------- CONTEXT ----------
class BookingRequest:
    def __init__(self):
        self.state = Created()

    def next(self):
        self.state.next_state(self)

    def cancel(self):
        self.state.cancel(self)


# ---------- DEMO ----------
if __name__ == "__main__":
    request = BookingRequest()

    print("\n--- Демонстрация процесса бронирования ---\n")

    request.next()      # Created → PendingPayment
    request.next()      # PendingPayment → Paid
    request.next()      # Paid → Confirmed

    print("\nПопытка отменить после подтверждения:\n")
    request.cancel()    # Нельзя отменить


from abc import ABC, abstractmethod


# -------------------------- ACTORS -------------------------------
class User(ABC):
    @abstractmethod
    def role(self):
        pass


class Student(User):
    def role(self):
        return "Студент"

    # --- Use Cases ---
    def register(self):
        print("[Студент] Регистрация выполнена")

    def login(self):
        print("[Студент] Авторизация выполнена")

    def view_courses(self):
        print("[Студент] Просмотр доступных курсов")

    def enroll(self, course):
        print(f"[Студент] Записался на курс: {course}")

    def take_test(self, test):
        print(f"[Студент] Прошел тест: {test}")

    def leave_review(self, course):
        print(f"[Студент] Оставил отзыв на курс: {course}")


class Instructor(Student):   # Наследует функционал студента
    def role(self):
        return "Преподаватель"

    # --- Instructor Use Cases ---
    def create_course(self, title):
        print(f"[Преподаватель] Создал курс: {title}")

    def edit_course(self, title):
        print(f"[Преподаватель] Отредактировал курс: {title}")

    def add_material(self, title):
        print(f"[Преподаватель] Добавил материалы для курса: {title}")

    def create_test(self, title):
        print(f"[Преподаватель] Создал тест: {title}")

    def view_statistics(self):
        print("[Преподаватель] Просмотр статистики успеваемости студентов")

    def moderate_reviews(self):
        print("[Преподаватель] Модерация отзывов выполнена")


class Admin(Instructor):   # Наследует Instructor, значит и Student
    def role(self):
        return "Администратор"

    # --- Admin Use Cases ---
    def manage_users(self):
        print("[Администратор] Управление учетными записями выполнено")

    def manage_categories(self):
        print("[Администратор] Управление категориями курсов выполнено")

    def view_analytics(self):
        print("[Администратор] Просмотр аналитики системы")


# -------------------------- DEMO SCENARIOS -------------------------------
if __name__ == "__main__":
    print("\n======== Демонстрация вариантов использования (Use Cases) ========\n")

    student = Student()
    instructor = Instructor()
    admin = Admin()

    # ---------------- Student Actions ----------------
    print("---- СТУДЕНТ ----")
    student.register()
    student.login()
    student.view_courses()
    student.enroll("Python Beginner")
    student.take_test("Python Intro Test")
    student.leave_review("Python Beginner")

    # ---------------- Instructor Actions ----------------
    print("\n---- ПРЕПОДАВАТЕЛЬ ----")
    instructor.create_course("Data Science")
    instructor.edit_course("Data Science")
    instructor.add_material("Data Science")
    instructor.create_test("DS Test 1")
    instructor.view_statistics()
    instructor.moderate_reviews()
    instructor.take_test("Test for course testing")

    # ---------------- Admin Actions ----------------
    print("\n---- АДМИНИСТРАТОР ----")
    admin.manage_users()
    admin.manage_categories()
    admin.view_analytics()
    admin.enroll("AI Course")        # унаследовано от Student
    admin.take_test("AI Test")       # тоже от Student

